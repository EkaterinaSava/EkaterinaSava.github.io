---
layout: post
title: Ментальные модели для JavaScript / via Dan Abramov mails
---

:mortar_board: Очередная попытка разобраться с JS-ом. Буду записывать основные тезисы.

_Этот пост существует тут исключительно для понимания мной материала._


---


<h2 class="post__small-heading">:large_blue_circle: Письмо #1 / Mental Models</h2>

Ментальные модели [(wiki)](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BD%D1%82%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8) — основанные на предыдущем опыте идеи, стратегии, способы понимания, существующие в уме человека и направляющие его действия.

Дэн пишет о том, что ММ — это сочетание визуальных, пространственных и механических умственных сокращений, которые мы используем, в том числе, читая и пытаясь понять код. Осноная проблема в том, что эти модели могли быть неверно сформированы под действием тех или иных факторов. И цель его рассылки — помочь людям выявить проблемы в ментальных моделях о языке JavaScript и устранить их, постепенно выстраивая более точную модель.

---

<h2 class="post__small-heading">:large_blue_circle: Письмо #2 / The JavaScript Universe</h2>

Одна их самых важных вещей во вселенной JavaScript — значения (value).

Первый тип значений — примитивы. Мы не можем манипулировать ими из своего кода: они словно звезды, делекие и холодные. Второй тип значений — объекты и функции. Они больше похожи на камни, плавающие рядом с нашим кодом. И они достаточно близко, чтобы мы могли ими манипулировать.

Типы значений ведут себя сходным образом. И их всего 9.

__Primitive Values__:
- Undefined (undefined), used for unintentionally missing values.
- Null (null), used for intentionally missing values.
- Booleans (true and false), used for logical operations.
- Numbers (-100, 3.14, and others), used for math calculations.
- Strings ("hello", "abracadabra", and others), used for text.
- Symbols (uncommon), used to hide implementation details.
- BigInts (uncommon and new), used for math on big numbers.

__Objects and Functions__:
- Objects ({} and others), used to group related data and code.
- Functions (x => x * 2 and others), used to refer to code.


Чтобы узнать тип значения, используется оператор `typeof`.

__Важно!__ В JavaScript нет других фундаментальных типов значений, кроме тех, которые мы только что перечислили. Остальные — объекты! Даже массивы, даты и регулярные выражения являются объектами.

---

<h2 class="post__small-heading">:large_blue_circle: Письмо #3 / Values and Variables</h2>

Полезное из квиза:
* `typeof(value) === "date"` всегда ложно, потому что такого типа значений не существует.
* `typeof(null)` не `object` (!), а само по себе значение, несмотря на то, что именно это будет написано в консоли, это [старая ошибка в JS](https://2ality.com/2013/10/typeof-null.html), которую уже невозможно исправить
* `typeof(typeof(value))` всегда "string": typeof (value) всегда дает нам одну из предопределенных строк: «undefined», «boolean», «number» и так далее, так что typeof любого из них - это «строка».

Итак. __Примитивы невозможно изменить__. Они иммутабельны (= неизменяемы). Только для чтения. Мы ничего не можем сделать в нашем коде, чтобы повлиять на них или изменить их каким-либо образом. Они остаются такими, какие они есть. 

Но! Здесь важно понимать, что __переменные — это не значения__. Каждая переменная указывает на определенное значение. Мы можем изменить значение, на которое оно указывает, используя оператор присваивания `=`. Пример:

```
let pet = 'Narwhal';
pet = 'The Kraken';
console.log(pet); // "The Kraken"
```

Здесь мы не меняем строку. Мы меняем значение переменной.

```
let x = 10;
let y = x;
x = 0;
```

А здесь мы не меняем значение `y` в тот момент, когда присваиваем `x = 0`, потому что переменные всегда указывают на значения, они не могут указывать друг на друга. Поэтому в конце переменная `x` указывает на значение 0, а переменная `y` указывает на значение 10.

---

<h2 class="post__small-heading">:large_blue_circle: Письмо #4 / Counting the Values</h2>

Для построения "правильной" ментальной модели JSa лучше всего не использовать низкоуровневые детали: значения — это не «указатель» (pointer) или «ячейка в памяти» (memory address), это «значение» (value). Не нужно позволять «ячейкам памяти» и другим метафорам низкого уровня отвлекать вас от создания точной высокоуровневой ментальной модели JavaScript. Если вы научитесь использовать только низкоуровневые ментальные модели, вам будет трудно понять, что может или не может происходить в коде JavaScript.

Фундамент нашей ММ: 
* вселенная JS полна значений (values) 
* каждое значение принадлежит одному из нескольких встроенных типов
* некоторые из этих типов являются примитивными, что делает значения этих типов неизменными
* переменные - это «провода», указывающие от имен в нашем коде на значения

###### Undefined type

Существует только одно значение этого типа — `undefined`

В JavaScript он представляет концепцию __непреднамеренно пропущенного значения__.

Это значение можно использовать целенаправленно, однако, чаше всего `undefined` «встречается естественным образом». Это проявляется в некоторых ситуациях, когда JavaScript не знает, какое значение вы хотите. Например, если вы забудете назначить переменную, она будет указывать на `undefined`:

```
let bandersnatch;
console.log(bandersnatch); // undefined
```

###### Null

Не вдаваясь в детали, енкоторые думают, что `null` — это сестра `undefined`, ведь иногда они ведут себя очень похоже. И к тому же, `null` — тоже единственное значение своего типа. Но к тому же лжец!

```
console.log(typeof(null)); // "object" (a lie!)
```

Не попадайтесь в эту ловушку! Это примитивное значение и оно не ведет себя как объект. К сожалению, такое поведение `typeof(null)` является исторической случайностью, с которой нам придется жить вечно.

На практике `null` используется для __намеренно пропущенных значений__. Почему же у нас есть оба значения — `null` и `undefined`? Это может помочь отличить ошибку кодирования (которая может привести к `undefined`) от валидно пропущенных данных (которые вы можете выразить как `null`).

###### Booleans

Как и день и ночь, есть только два логических значения: `true` и `false`.

```
console.log(typeof(true)); // "boolean"
console.log(typeof(false)); // "boolean"
```

###### Numbers

Особо ничем не примечательны, кроме популярной "городской легенды":

```
console.log(0.1 + 0.2 === 0.3); // false
console.log(0.1 + 0.2 === 0.30000000000000004); // true
```

Однако такое поведение не является специфичным для JavaScript и обусловлено существованием математики (и чисел) с плавающей точкой, то есть, JavaScript реализует стандарт под названием «математика с плавающей точкой» Стоит отметить, что математика с плавающей точкой включает в себя несколько специальных чисел. Иногда вы можете столкнуться с `NaN`, `Infinity`, `-Infinity` и `-0`. Они существуют, потому что иногда вы можете выполнять такие операции, как `1/0`, и JavaScript должен как-то представлять их результат. Примеры:

```
let scale = 0;
let a = 1 / scale; // Infinity
let b = 0 / scale; // NaN
let c = -a; // -Infinity
let d = 1 / c; // -0
```

Еще может смутить такая вещь:
```
console.log(typeof(NaN)); // "number"
```

Однако здесь нет хитрости. С точки зрения JavaScript, `NaN` является числовым значением. Это не null, undefined, строка или какой-либо другой тип. Но в математике с плавающей точкой название этого термина «not a number», потому что он представляет идею «недействительного» (invalid) числа.

###### BigInts

`BigInts` были добавлены недавно в JavaScript, поэтому пока вы не увидите их широкого применения. Если вы используете старый браузер, они не будет работать. Обычные числа не могут точно представлять большие целые числа, поэтому для заполнения этого пробела были добавлены `BigInts`. Это отлично подходит для финансовых расчетов, где точность особенно важна. Но стоит иметь в виду, что ничто не бесплатно. Операции с действительно огромными числами могут занять значительное время и ресурсы.

##### Strings

Строки представляют текст в JavaScript. Есть три способа написания строк (одинарные, двойные и обратные кавычки), но результат будет одинаков:
```
console.log(typeof("こんにちは")); // "string"
console.log(typeof('こんにちは')); // "string"
console.log(typeof(`こんにちは`)); // "string"
```

Пустая строка также является строкой:
```
console.log(typeof('')); // "string"
```

В целом, можно сказать, что во вселенной JavaScript существует любая из возможных строк.

###### Symbols

`Symbols` — сравнительно недавнее дополнение к языку.

```
let alohomora = Symbol();
console.log(typeof(alohomora)); // "symbol"
```

Трудно объяснить их назначение и поведение, не углубляясь в объекты и свойства, поэтому сейчас мы их пропустим. 

###### Objects

Объекты включают в себя массивы, даты, RegExps и другие не-примитивные значения:

```
console.log(typeof({})); // "object"
console.log(typeof([])); // "object"
console.log(typeof(new Date())); // "object"
console.log(typeof(/\d+/)); // "object"
console.log(typeof(Math)); // "object"
```

В отличие от всего, объекты __не являются примитивными значениями__. Это также означает, что по умолчанию они изменчивы или мутабельны (mutable). Мы можем получить доступ к их свойствам через `.` или `[]`:
```
let rapper = { name: 'Malicious' };
rapper.name = 'Malice'; // Dot notation
rapper['name'] = 'No Malice'; // Bracket notation
```

В нашей ментальной модели все обсуждаемые нами примитивные значения — `null`, `undefined`, `booleans`, `numbers` и `strings` — «существовали всегда». Мы не можем «сделать» новую строку или новое число, мы можем только «вызвать» это значение. С объектами все иначе: каждый раз, когда мы используем литерал объекта `{}`, мы создаем новое значение объекта.

###### Functions

Особенно странно думать о функциях как о значениях, которые отделены от кода. Именно они и есть код.

Важный пример:
```
for (let i = 0; i < 7; i++) {
  let dig = function() {
    // Do nothing
  };
  console.log(dig);
}
```

Сколько здесь функций? Одна или семь? Приведенный выше фрагмент содержит __одно определение__ функции в коде, но создает __семь значений__ функции! Вот почему важно разделять эти понятия. Каждый раз, когда мы выполняем строку кода, содержащую объявление функции, в нашей вселенной появляется новое значение функции.


##### Итог

Давайте пересчитаем количество значений каждого примитивного типа:

* __Undefined__: только одно значение `undefined`
* __Null__: только одно значение `null`
* __Booleans__: два значения — `true` и `false`
* __Numbers__: одно значение для каждого математического числа с плавающей точкой
* __BigInts__: одно значение для каждого мыслимого целого числа
* __Strings__: одно значение для каждой мыслимой строки

Типы ниже являются специальными, потому что они позволяют нам создавать наши собственные значения:

* __Objects__: одно значение для каждого объекта, который мы создаем
* __Function__: одно значение для каждого определения функции, через которое мы переходим

---

<h2 class="post__small-heading">:large_blue_circle: Письмо #5 / </h2>

---

<!-- 27/01/2020 -->
